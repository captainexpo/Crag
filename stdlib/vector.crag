import "libc/libc.crag" as libc;

pub enum VecError(i32){
    ALLOC_ERROR = 1,
    OUT_OF_BOUNDS,
}

pub struct Vec<T> {
    cur_elem: usize,
    size: usize,
    elements: *T,

    fn init(self: *Vec::<T>) -> i32!VecError {
        self.size = 10;
        self.elements = libc::stdlib::malloc(self.size*sizeof(T)) as *T;
        if (self.elements == null){
            return! VecError:ALLOC_ERROR;
        }
        return 0;
    }

    fn append(self: *Vec::<T>, elem: T) -> i32!VecError {
        if (self.cur_elem >= self.size) {
            self.size *= 2;
            self.elements = libc::stdlib::realloc(self.elements as *void, self.size * sizeof(T)) as *T;
            if (self.elements == null){
                return! VecError:ALLOC_ERROR;
            }
        }
        self.elements[self.cur_elem] = elem;
        self.cur_elem += 1;
        return 0;
    }

    fn set(self: *Vec::<T>, idx: usize, elem: T) -> i32!VecError {
        if (idx >= self.cur_elem || idx < 0) {
            return! VecError:OUT_OF_BOUNDS;
        }
        self.elements[idx] = elem;
        return 0;
    }

    fn get(self: *Vec::<T>, idx: usize) -> T!VecError {
        if (idx >= self.cur_elem || idx < 0) {
            return! VecError:OUT_OF_BOUNDS;
        }
        return self.elements[idx];
    }

    fn len(self: *Vec::<T>) -> usize {
        return self.cur_elem;
    }
}

fn new<T>() -> Vec::<T> {
    let v = Vec::<T> { cur_elem: 0, size: 0, elements: null };
    v.init();
    return v;
}

