import "libc/libc.crag" as libc;

pub enum StrError(i32) {
    ALLOC_ERROR = 1,
    OUT_OF_BOUNDS,
}

pub struct Str {
    value: *u8,
    length: usize,
    is_heap: bool,

    fn len(self: *Str) -> usize {
        return self.length;
    }

    fn is_empty(self: *Str) -> bool {
        return self.length == 0;
    }

    fn is_null(self: *Str) -> bool {
        return self.value == null;
    }

    fn c_str(self: *Str) -> *u8 {
        return self.value;
    }

    fn at(self: *Str, index: usize) -> u8!StrError {
        if (index >= self.length) {
            return! StrError:OUT_OF_BOUNDS;
        }
        return self.value[index];
    }

    fn concat(self: *Str, other: Str) -> u8!StrError {
        let new_length: usize = self.length + other.length;
        let new_value: *u8 = libc::stdlib::malloc(new_length + 1) as *u8;
        if (new_value == null) {
            return! StrError:ALLOC_ERROR;
        }

        if (self.value != null) {
            libc::string::memcpy(new_value as *void, self.value as *void, self.length);
        }
        if (other.value != null) {
            libc::string::memcpy(new_value + self.length as *u8 as *void, other.value as *void, other.length);
        }
        new_value[new_length] = 0;

        if (self.is_heap && self.value != null) {
            libc::stdlib::free(self.value);
        }

        self.value = new_value;
        self.length = new_length;
        return 0;
    }

    fn substr(self: *Str, start: usize, end: usize) -> Str!StrError{
        if (start >= self.length || end > self.length || start >= end) {
            return! StrError:OUT_OF_BOUNDS;
        }

        let sub_length: usize = end - start;
        let sub_value: *u8 = libc::stdlib::malloc(sub_length + 1) as *u8;
        if (sub_value == null) {
            return! StrError:ALLOC_ERROR;
        }

        libc::string::memcpy(sub_value as *void, (self.value + start as *u8) as *void, sub_length);
        sub_value[sub_length] = 0;

        return Str{value: sub_value, length: sub_length, is_heap: true};
    }

    fn free(self: *Str) -> void {
        if (self.value != null && self.is_heap) {
            libc::stdlib::free(self.value);
            self.value = null;
            self.length = 0;
        }
    }
}

pub fn str(c_str: *u8) -> Str {
    if (c_str == null) {
        return Str{value: null, length: 0, is_heap: false};
    }

    let length: usize = 0;
    let ptr: *u8 = c_str;
    while (ptr.* != 0) {
        length += 1;
        ptr += 1 as *u8;
    }

    return Str{value: c_str, length: length, is_heap: false};
}
